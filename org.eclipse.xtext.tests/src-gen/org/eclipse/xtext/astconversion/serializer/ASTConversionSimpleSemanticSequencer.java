/*
 * generated by Xtext
 */
package org.eclipse.xtext.astconversion.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.astconversion.astConversionSimple.ActionNewX;
import org.eclipse.xtext.astconversion.astConversionSimple.Addition;
import org.eclipse.xtext.astconversion.astConversionSimple.AstConversionSimplePackage;
import org.eclipse.xtext.astconversion.astConversionSimple.AutoClass;
import org.eclipse.xtext.astconversion.astConversionSimple.AutoExplicitClass;
import org.eclipse.xtext.astconversion.astConversionSimple.CustomASTClass;
import org.eclipse.xtext.astconversion.astConversionSimple.CustomCopyASTClass;
import org.eclipse.xtext.astconversion.astConversionSimple.Element;
import org.eclipse.xtext.astconversion.astConversionSimple.HoistingActionNew;
import org.eclipse.xtext.astconversion.astConversionSimple.HoistingActionNewX;
import org.eclipse.xtext.astconversion.astConversionSimple.Lists;
import org.eclipse.xtext.astconversion.astConversionSimple.ManualClass;
import org.eclipse.xtext.astconversion.astConversionSimple.MapEntry;
import org.eclipse.xtext.astconversion.astConversionSimple.MapEntryCustom;
import org.eclipse.xtext.astconversion.astConversionSimple.MapEntryCustom2;
import org.eclipse.xtext.astconversion.astConversionSimple.Other;
import org.eclipse.xtext.astconversion.astConversionSimple.Program;
import org.eclipse.xtext.astconversion.astConversionSimple.Reference;
import org.eclipse.xtext.astconversion.astConversionSimple.ReturnsNewX;
import org.eclipse.xtext.astconversion.astConversionSimple.Sequence;
import org.eclipse.xtext.astconversion.astConversionSimple.X;
import org.eclipse.xtext.astconversion.astConversionSimple.Y;
import org.eclipse.xtext.astconversion.services.ASTConversionSimpleGrammarAccess;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ASTConversionSimpleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ASTConversionSimpleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AstConversionSimplePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AstConversionSimplePackage.ACTION_NEW_X:
				sequence_ActionNew(context, (ActionNewX) semanticObject); 
				return; 
			case AstConversionSimplePackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case AstConversionSimplePackage.AUTO_CLASS:
				sequence_AutoClass(context, (AutoClass) semanticObject); 
				return; 
			case AstConversionSimplePackage.AUTO_EXPLICIT_CLASS:
				sequence_AutoExplicitClass(context, (AutoExplicitClass) semanticObject); 
				return; 
			case AstConversionSimplePackage.CUSTOM_AST_CLASS:
				sequence_CustomASTClass(context, (CustomASTClass) semanticObject); 
				return; 
			case AstConversionSimplePackage.CUSTOM_COPY_AST_CLASS:
				sequence_CustomCopyASTClass(context, (CustomCopyASTClass) semanticObject); 
				return; 
			case AstConversionSimplePackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case AstConversionSimplePackage.HOISTING_ACTION_NEW:
				sequence_HoistingActionNew(context, (HoistingActionNew) semanticObject); 
				return; 
			case AstConversionSimplePackage.HOISTING_ACTION_NEW_X:
				sequence_HoistingActionNew(context, (HoistingActionNewX) semanticObject); 
				return; 
			case AstConversionSimplePackage.LISTS:
				sequence_Lists(context, (Lists) semanticObject); 
				return; 
			case AstConversionSimplePackage.MANUAL_CLASS:
				sequence_ManualClass(context, (ManualClass) semanticObject); 
				return; 
			case AstConversionSimplePackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case AstConversionSimplePackage.MAP_ENTRY_CUSTOM:
				sequence_MapEntryCustom(context, (MapEntryCustom) semanticObject); 
				return; 
			case AstConversionSimplePackage.MAP_ENTRY_CUSTOM2:
				sequence_MapEntryCustom2(context, (MapEntryCustom2) semanticObject); 
				return; 
			case AstConversionSimplePackage.OTHER:
				sequence_Other(context, (Other) semanticObject); 
				return; 
			case AstConversionSimplePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case AstConversionSimplePackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case AstConversionSimplePackage.RETURNS_NEW_X:
				sequence_ReturnsNew(context, (ReturnsNewX) semanticObject); 
				return; 
			case AstConversionSimplePackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case AstConversionSimplePackage.X:
				sequence_X(context, (X) semanticObject); 
				return; 
			case AstConversionSimplePackage.Y:
				sequence_Y(context, (Y) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionNew returns ActionNewX
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_ActionNew(ISerializationContext context, ActionNewX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ACTION_NEW_X__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ACTION_NEW_X__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionNewAccess().getValueIDTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sequence returns Addition
	 *     Sequence.Sequence_2_0 returns Addition
	 *     Addition returns Addition
	 *
	 * Constraint:
	 *     (left=ID right=ID)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getLeftIDTerminalRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightIDTerminalRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns AutoClass
	 *     AutoClass returns AutoClass
	 *
	 * Constraint:
	 *     (ref=Reference name=ID)
	 */
	protected void sequence_AutoClass(ISerializationContext context, AutoClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.AUTO_CLASS__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.AUTO_CLASS__REF));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAutoClassAccess().getRefReferenceParserRuleCall_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getAutoClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns AutoExplicitClass
	 *     AutoExplicitClass returns AutoExplicitClass
	 *
	 * Constraint:
	 *     (ref=Reference name=ID)
	 */
	protected void sequence_AutoExplicitClass(ISerializationContext context, AutoExplicitClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.AUTO_EXPLICIT_CLASS__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.AUTO_EXPLICIT_CLASS__REF));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAutoExplicitClassAccess().getRefReferenceParserRuleCall_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getAutoExplicitClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns CustomASTClass
	 *     CustomASTClass returns CustomASTClass
	 *
	 * Constraint:
	 *     (ref=Reference name=ID)
	 */
	protected void sequence_CustomASTClass(ISerializationContext context, CustomASTClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.CUSTOM_AST_CLASS__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.CUSTOM_AST_CLASS__REF));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomASTClassAccess().getRefReferenceParserRuleCall_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getCustomASTClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns CustomCopyASTClass
	 *     CustomCopyASTClass returns CustomCopyASTClass
	 *
	 * Constraint:
	 *     (ref=Reference name=ID)
	 */
	protected void sequence_CustomCopyASTClass(ISerializationContext context, CustomCopyASTClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.CUSTOM_COPY_AST_CLASS__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.CUSTOM_COPY_AST_CLASS__REF));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomCopyASTClassAccess().getRefReferenceParserRuleCall_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getCustomCopyASTClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns Element
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (name=ID type=ChangeKind? value+=ChangeKind+)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HoistingActionNew returns HoistingActionNew
	 *
	 * Constraint:
	 *     x=ID
	 */
	protected void sequence_HoistingActionNew(ISerializationContext context, HoistingActionNew semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ACTION_NEW__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ACTION_NEW__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHoistingActionNewAccess().getXIDTerminalRuleCall_1_1_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HoistingActionNew returns HoistingActionNewX
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_HoistingActionNew(ISerializationContext context, HoistingActionNewX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ACTION_NEW_X__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ACTION_NEW_X__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHoistingActionNewAccess().getValueIDTerminalRuleCall_0_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lists returns Lists
	 *
	 * Constraint:
	 *     (a=MapEntry b=MapEntryCustom c+=MapEntry+ d+=MapEntryCustom+ e=MapEntryCustom2)
	 */
	protected void sequence_Lists(ISerializationContext context, Lists semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns ManualClass
	 *     ManualClass returns ManualClass
	 *
	 * Constraint:
	 *     (ref=Reference name=ID)
	 */
	protected void sequence_ManualClass(ISerializationContext context, ManualClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.MANUAL_CLASS__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.MANUAL_CLASS__REF));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.ENTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getManualClassAccess().getRefReferenceParserRuleCall_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getManualClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryCustom2 returns MapEntryCustom2
	 *
	 * Constraint:
	 *     (keys+=INT keys+=INT* value=Reference)
	 */
	protected void sequence_MapEntryCustom2(ISerializationContext context, MapEntryCustom2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryCustom returns MapEntryCustom
	 *
	 * Constraint:
	 *     (keys+=ID keys+=ID* value=Reference)
	 */
	protected void sequence_MapEntryCustom(ISerializationContext context, MapEntryCustom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (keys+=ID keys+=ID* value=INT)
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entry returns Other
	 *     Other returns Other
	 *
	 * Constraint:
	 *     (name=ID (content=Reference | content=AutoClass))
	 */
	protected void sequence_Other(ISerializationContext context, Other semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         entries+=Entry+ 
	 *         sequence+=Sequence+ 
	 *         returnsNew=ReturnsNew 
	 *         actionNew=ActionNew 
	 *         list=Lists 
	 *         hoistingAlternative=HoistingAlternative 
	 *         hoistingActionNew=HoistingActionNew
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReturnsNew returns ReturnsNewX
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_ReturnsNew(ISerializationContext context, ReturnsNewX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.RETURNS_NEW_X__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.RETURNS_NEW_X__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnsNewAccess().getValueIDTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sequence returns Sequence
	 *     Sequence.Sequence_2_0 returns Sequence
	 *
	 * Constraint:
	 *     (expressions+=Sequence_Sequence_2_0 expressions+=Addition)
	 */
	protected void sequence_Sequence(ISerializationContext context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HoistingAlternative returns X
	 *     X returns X
	 *
	 * Constraint:
	 *     val=ID
	 */
	protected void sequence_X(ISerializationContext context, X semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ALTERNATIVE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ALTERNATIVE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXAccess().getValIDTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HoistingAlternative returns Y
	 *     Y returns Y
	 *
	 * Constraint:
	 *     (val=ID y=ID)
	 */
	protected void sequence_Y(ISerializationContext context, Y semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ALTERNATIVE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.HOISTING_ALTERNATIVE__VAL));
			if (transientValues.isValueTransient(semanticObject, AstConversionSimplePackage.Literals.Y__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AstConversionSimplePackage.Literals.Y__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYAccess().getValIDTerminalRuleCall_1_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getYAccess().getYIDTerminalRuleCall_2_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
}
